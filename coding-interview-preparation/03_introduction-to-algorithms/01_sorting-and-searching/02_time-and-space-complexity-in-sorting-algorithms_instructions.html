<meta charset="utf-8"/>
<co-content>
 <p variant="body1">
  You previously learned that time and space complexity are a means of evaluating code efficiency. In this reading, you will explore time and space complexity in both the selection sort and quicksort algorithms. These are common algorithms that are used to sort data in an array.
 </p>
 <h2 level="2" variant="h2semibold">
  <strong>
   Selection sort
  </strong>
 </h2>
 <p variant="body1">
  Selection sort is a sorting algorithm that works from a very simple principle. Take an array to items and iterate from left to right. Starting with the first place on the index, iterate over the entire array and swap this value with the lowest value found to the right of this item. Repeat until the entire array is sorted.
 </p>
 <p variant="body1">
  Selection sort has:
 </p>
 <ul bullettype="bullets">
  <li>
   <p variant="body1">
    Worst case time complexity is
    <var>
     O(N^2)
    </var>
   </p>
  </li>
  <li>
   <p variant="body1">
    Average case time complexity is
    <var>
     O(N^2)
    </var>
   </p>
  </li>
  <li>
   <p variant="body1">
    Best case time complexity is
    <var>
     O(N^2)
    </var>
   </p>
  </li>
  <li>
   <p variant="body1">
    Space complexity:
    <var>
     O(1)
    </var>
    <em>
     Auxiliary
    </em>
    .
   </p>
  </li>
 </ul>
 <p variant="body1">
  To perform selection sort, take the following steps:
 </p>
 <ul bullettype="bullets">
  <li>
   <p variant="body1">
    Find the smallest value and swap it with the first value of the array
   </p>
  </li>
  <li>
   <p variant="body1">
    Find the second smallest value and swap it with the second place in the array
   </p>
  </li>
  <li>
   <p variant="body1">
    Repeat until all items are changed from ordered from smallest to largest
   </p>
  </li>
 </ul>
 <p variant="body1">
  Time complexity is determined in relation to the number of transactions enacted. Given a list of size
  <var>
   n
  </var>
  , the compiler must search each entry in the list to identify the smallest item, then perform a swap to index location 0. The pseudocode for the algorithm is as below.
 </p>
 <pre language="plain_text">for(i = 0; i &lt; n-1; i++)
int min_index=List[i]
    for(j=i+1; j&lt;n;j++)
        if(List[j] &lt; List[min_index])
            min_index=j 
    swap(List[i], List[min_index])</pre>
 <p variant="body1">
  <strong>
  </strong>
  Line 1 says that the length of the list
  <var>
   List
  </var>
  must be searched
  <var>
   n-1
  </var>
  times. Line 2 sets a temporary variable to hold the lowest value. Line 3 is an inner loop that must iterate through the loop
  <var>
   n-1
  </var>
  times. Line 4 checks if the value found in position
  <var>
   List[j]
  </var>
  is smaller than the current lowest value. If so, the position of that element is recorded. At the end of each inner loop, the value found to be the lowest is swapped with position
  <var>
   i
  </var>
  in the index,
  <var>
   i
  </var>
  is incremented and the procedure begins again. Always check the next item in the list until every item has been checked.
 </p>
 <p variant="body1">
  There are four considerations to be made when evaluating this algorithm.
 </p>
 <ol bullettype="numbers">
  <li>
   <p variant="body1">
    Worst case scenario: Given a list sorted in reverse order, how many comparisons are made? The inner and outer loop will have to run
    <var>
     n
    </var>
    times so it can be determined that worst case
    <var>
     = O(n^2)
    </var>
    .
   </p>
  </li>
  <li>
   <p variant="body1">
    Average comparison: Regardless of the order of the list, every item must be checked against average case
    <var>
     = O(n^2)
    </var>
    .
   </p>
  </li>
  <li>
   <p variant="body1">
    Best comparison: Given a sorted list of how many comparisons must be made. Again, regardless of the items in the list, every item must be checked, so best case
    <var>
     = O(n^2)
    </var>
    .
   </p>
  </li>
  <li>
   <p variant="body1">
    Finally, what is the space complexity of this approach? Because an in-place swap is being performed, no temporary array is required. There are three temporary variables
    <var>
     i
    </var>
    ,
    <var>
     j
    </var>
    and
    <var>
     min_index
    </var>
    ; however, these are not dependent on the list size. So, the image doubles the list, and the space complexity does not increase accordingly. Therefore, space complexity
    <var>
     = O(1)
    </var>
    .
   </p>
  </li>
 </ol>
 <p variant="body1">
  When evaluating time complexity, a good rule of thumb is to consider what will happen if the list is doubled. Naturally, the inner and outer loops will have to increase by no iterations to match the additional elements in the list. Therefore, it can be concluded that the time complexity increases with the size.
 </p>
 <h2 level="2" variant="h2semibold">
  <strong>
   Quicksort
  </strong>
 </h2>
 <p variant="body1">
  Quicksort is a sorting approach that uses a divide-and-conquer methodology. Given an array of items, a place is determined on the array on which to split the array and this is called the pivot point. All values greater than this point go to the right and all values less than this point go to the left. In this step, you have two arrays. The same process is applied to these arrays until there are no elements left to sort.
 </p>
 <p variant="body1">
  Quicksort has:
 </p>
 <ul bullettype="bullets">
  <li>
   <p variant="body1">
    Worst case time complexity
    <var>
     O(n^2)
    </var>
   </p>
  </li>
  <li>
   <p variant="body1">
    Average case time complexity
    <var>
     O(n log n)
    </var>
   </p>
  </li>
  <li>
   <p variant="body1">
    Best case time complexity
    <var>
     O(n log n)
    </var>
   </p>
  </li>
  <li>
   <p variant="body1">
    Space complexity
    <var>
     O(n)
    </var>
   </p>
  </li>
 </ul>
 <p variant="body1">
 </p>
 <p variant="body1">
  To perform quicksort, take the following steps:
 </p>
 <ul bullettype="bullets">
  <li>
   <p variant="body1">
    Select a point on the list to pivot on.
   </p>
  </li>
  <li>
   <p variant="body1">
    Split the list into two lists, items to the left of the pivot and items to the right.
   </p>
  </li>
  <li>
   <p variant="body1">
    Set variables
    <var>
     i
    </var>
    to iterate from left to right on the left of the pivot. Set variable
    <var>
     j
    </var>
    to repeat from right to left on the left side of the pivot.
   </p>
  </li>
  <li>
   <p variant="body1">
    The variables
    <var>
     i
    </var>
    on the left look for a value greater than or equal to the pivot. Variables
    <var>
     j
    </var>
    on the right look for a value less than or equal to the pivot.
   </p>
  </li>
  <li>
   <p variant="body1">
    When
    <var>
     j &lt; i
    </var>
    , the values at these index locations are swapped, this is repeated until
    <var>
     i
    </var>
    and
    <var>
     j
    </var>
    meet at the pivot point.
   </p>
  </li>
  <li>
   <p variant="body1">
    Partition the list values into two lists, one to the left and one to the right of the pivot. Repeat the process on each of the resulting arrays.
   </p>
  </li>
  <li>
   <p variant="body1">
    Recursively apply the algorithm.
   </p>
  </li>
 </ul>
 <p variant="body1">
 </p>
 <p variant="body1">
  The pseudocode below for quicksort is done recursively.
 </p>
 <ul bullettype="bullets">
  <li>
   <p variant="body1">
    Starting at the leftmost element, each subsequent element is checked, and if it is found to be less, it is swapped.
   </p>
  </li>
  <li>
   <p variant="body1">
    Line 3 calls the partition method, which begins on line 8.
   </p>
  </li>
  <li>
   <p variant="body1">
    Line 10 determines the more significant element to be placed on the right side of the list. Line 10 sets a variable
    <var>
     i
    </var>
    to be assigned to the index of the smaller element. The variable
    <var>
     j
    </var>
    is then used to check the elements to the right from which to make a comparison with the current smallest element.
   </p>
  </li>
  <li>
   <p variant="body1">
    Line 12 determines if there is to be a swap, a smaller element on the right will require moving to the current index position. Line 4 is for sorting the left array.
   </p>
  </li>
  <li>
   <p variant="body1">
    Line 5 is for sorting the right array. At each iteration, the size of the array to be sorted is halved. The arrays will continually break down until only one element is left in the subarrays. The result of calling partition will determine the location of the current element. This location is incremented and repeated until every element rests in its naturally ordered position.
    <strong>
    </strong>
   </p>
  </li>
 </ul>
 <pre language="plain_text">QuickSort(List, low, high)
        if(low&lt;high) 
	pivot=partition(List, high, low)
	QuickSort(List, how, pivot-1)
	QuickSort(List, pivot+1, high) 

Partition(List,high,low)
        pivot=arr[high]
        i=(low-1)
        for j = low; j &lt;= high-1; j++) 
	if(List[j] &lt; pivot)
	        i++
	        swap(List[i], List[j]) 
        swap(arr[i+1], List[j]) 
        return I + 1 
</pre>
 <p variant="body1">
 </p>
 <p variant="body1">
  Things to consider when evaluating this algorithm:
 </p>
 <ol bullettype="numbers">
  <li>
   <p variant="body1">
    Worst case scenario: this happens when the most significant element is consistently chosen as a pivot point. This will cause a loop to iterate over every element n from the left. The split will cause a search of every element on the right with none on the left,
    <var>
     O(n^2)
    </var>
    .
   </p>
  </li>
  <li>
   <p variant="body1">
    Average case scenario: an average pivot point is selected at every call. This will reduce the number of additional iterations required. So, there will be n iterations and an ever-decreasing
    <var>
     logn
    </var>
    iterative calls,
    <var>
     O(n*logn)
    </var>
    .
   </p>
  </li>
  <li>
   <p variant="body1">
    Best case scenario: The middle value is always selected, and the iteration space is halved at every iteration,
    <var>
     O(n*logn)
    </var>
    .
   </p>
  </li>
  <li>
   <p variant="body1">
    The iterative nature of the algorithm will impact the space complexity because the function call and variables are retained on the stack while the calculations are performed. However, the decision to use an in-place swap means no new array needs to be created,
    <var>
     O(log n)
    </var>
    .
   </p>
  </li>
 </ol>
 <p variant="body1">
  <strong>
   Conclusion
  </strong>
 </p>
 <p variant="body1">
  Two different sorting approaches have been broken down and analyzed through the lens of Big-O space and complexity. It has been shown that quicksort is more complex in implementation but returns overall quicker solutions. Selection sort is more simplistic and less code-heavy and requires less space, but will not generate results as effectively.
 </p>
 <p variant="body1">
  In this reading, you explored time and space complexity in both the selection sort and quicksort algorithms.
 </p>
 <p variant="body1">
 </p>
 <p>
 </p>
</co-content>
<style>
 body {
    padding: 50px 85px 50px 85px;
}

table th, table td {
    border: 1px solid #e0e0e0;
    padding: 5px 20px;
    text-align: left;
}
input {
    margin: 10px;
}
}
th {
    font-weight: bold;
}
td, th {
    display: table-cell;
    vertical-align: inherit;
}
img {
    height: auto;
    max-width: 100%;
}
pre {
    display: block;
    margin: 20px;
    background: #424242;
    color: #fff;
    font-size: 13px;
    white-space: pre-wrap;
    padding: 9.5px;
    margin: 0 0 10px;
    border: 1px solid #ccc;
}
</style>
<script async="" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">
</script>
<script type="text/x-mathjax-config">
 MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$$','$$'], ['$','$'] ],
      displayMath: [ ["\\[","\\]"] ],
      processEscapes: true
    }
  });
</script>
